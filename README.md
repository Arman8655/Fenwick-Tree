# توضیحات پروژه Fenwick Tree

ساختمان داده Fenwick tree در محاسبه مجموع عناصر ( پیشوندی یا بازه ای ) و آپدیت و بروزرسانی مقدار یک عنصر آرایه بکار می رود.
با استفاده از این ساختمان داده این دو عملیات در زمان O(logn) انجام می‌شوند در حالی که در آرایه معمولی باید n عدد را جمع کرده که O(n) زمان می‌برد.


در واقع در این ساختمان داده آرایه ها را به یک سری بازه تقسیم بندی می‌کنیم و مجموع هر بازه را در آرایه درخت نگه داری می‌کنیم
.
تقسیم بندی بازه ها بدین صورت است که ارزش هر ایندکس در آرایه اولیه به شکل باینری نوشته شده و با بررسی اعداد باینری از راست به چپ کم ارزش ترین بیت ۱ را می‌يابيم.
اگر بیت اول این ویژگی را داشت خود آن عدد در ایندکس مشابه در آرایه درخت قرار می‌گیرد. 
اگر بیت دوم این ویژگی را داشت با آن عدد با عدد قبل خود جمع شده و در ایندکس مشابه قرار می‌گیرد. 
و در صورتی که بیت سوم این شرایط را داشت، آن عدد با سه عدد قبلی خود جمع می‌شود و در آرایه نوشته می‌‌شود به طور کلی با ۲ (به توان جایگاه بیت ۱ منهای یک ) منهای یک عدد دیگر جمع می‌شود‌.

قبل از شروع توضیحات درباره تک تک کلاس ها و متد ها ابتدا معنی LSB را بفهمیم.

برای بدست آوردن LSB یک عدد آن عدد را باینری تبدیل کرده و سپس با حرکت از راست به چپ با دیدن اولین بیت یک ۲ را به توان جایگاه منهای یک آن بیت می‌رسانیم. 

پس اگه دقت کنیم برای ساخت آرایه درخت از LSB استفاده کردیم.


## کلاس FenwickTreeBase : 
دارای دو فیلد  آرایه درخت و n که تعداد اعضای آرایه را مشخص می‌کند است.

کانستراکتور که برای ساخت شی بکار می‌رود.

### متد update 
در متد آپدیت با ورودی گرفتن ایندکس و value مقدار ایندکس را به اندازه value تغییر می‌دهیم.
( اضافه کردن یک به ایندکس بخاطر این است که آرایه درخت از یک شروع می‌شود ) 

علت ایجاد حلقه هم به این دلیل است که با آپدیت باید همه مجموع های پیشوندی که شامل این ایندکس هستند نیز آپدیت شوند 
در خط آخر با and گرفتن در واقع طول بازه مربوط به tree[i] که برابر LSB(i) است با ایندکس جمع می‌شود که با این کار به اولین خانه بعدی که مربوط به اين عنصر است می‌رویم. 



### متد prefixSum 
در این متد با ورودی گرفتن یک ایندکس مجموع اعداد یک تا آن ایندکس را بدست می‌آوریم اما بدون طی کردن کل آرایه و در کمتر از زمان o(n).
در result مقدار مجموع را نگه می‌داریم 
با and گرفتن و کم کردن LSB(i) از ایندکس به آخر بازه قبلی می‌رویم تا مجموع آن بازه یعنی tree[i] را بدست بياوريم و تا زمانی که ایندکس برابر صفر شود ( به اول آرایه برسیم ) ادامه می‌دهیم.

## کلاس RangeSumQuery 
دارای یک فیلد درخت است که از کلاس قبلی ساخته شده است

متد آپدیت آن همان متد کلاس FenwickTreeBase را کال می‌کند.

### متد rangesum 
با ورودی گرفتن دو عدد l و r مجموع اعداد بین آن ها را بدست می‌آورد 
و این مجموع را با دوبار استفاده از متد prefixSum پیدا می‌کند.

## کلاس FenwickTreeoptimal 

این کلاس که از FenwickTreeBase ارث بری می‌کند به صورت بهینه o(n) یعنی بدون استفاده از آپدیت که از مرتبه O(nlogn) می‌شود، درخت را می‌سازیم.

در متد این کلاس ابتدا کلاس پایه را کال می‌کنیم تا اندازه درخت مشخص شود.

سپس آرایه ورودی را داخل درخت کپی می‌کنیم ( به طوری که اندیس درخت از یک شروع بشه ) 


در حلقه بعدی parent را به گونه ای تعریف می‌کنیم که تمام عنصر های بازه tree[i] و عناصر بعدی تا طول LSB(parent) را پوشش بدهد ( شامل tree[i])  برای این کار LSB(i) را با i جمع می‌کنیم
شرط if زمانی که گره والد دارد مجموع بازه کوچک تر را یعنی tree[i] را به والدش اضافه می‌کند.

به صورت کلی در این متد والد هر گره را پیدا می‌کنیم و مجموع بازه را به والد اضافه می‌کنیم.

## کلاس FenwickTree2D 

این کلاس همان عملیات درخت یک بعدی را در دو بعد انجام می‌دهد ( روی یک ماتریس ) 

### متد های update و prefixSum 
 منطق این دو متد مانند کلاس FenwickTreeBase  است و تنها تفاوت آنها این است که بجای یک بار پیمایش دوبار پیمایش انجام می‌شود یکبار به صورت ستونی توسط y و یکبار به صورت ردیفی توسط x انجام میشود. 

### متد rangeSum 
در این متد مجموع یک زیر ماتریس مستطیلی از (x1,y1) تا (x2,y2) را محاسبه می‌کنیم 

برای این کار از فرمول inclusion-exclusion استفاده می‌شود 
به این صورت که ابتدا همه ستون ها و ردیف های را جمع کرده و سپس ستون های قبل از x1 و ردیف های قبل از y1 که اضافه اند را کم می‌کنیم و در نهایت بخش هایی که دوباره کم شده اند را اضافه می‌کنیم.
.
## کلاس FenwickTest 
در این کلاس متد های گفته شده در کلاس قبل برای آرایه ای از ۱ تا ۵ برای Fenwick یک بعدی و ۱ تا ۹ برای Fenwick دو بعدی استفاده می‌شوند.











.
